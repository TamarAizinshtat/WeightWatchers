(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let counter = 1;
    let functionMap = new Map();
    exports.getDependencyConstructor = (dependency) => {
        if (dependency === null || dependency === undefined) {
            return "";
        }
        switch (typeof dependency.dependency) {
            case "string":
                return `var ${dependency.name} = ${dependency.name}_1 = '${dependency.dependency}';`;
            case "number":
                return `var ${dependency.name} = ${dependency.name}_1 = ${dependency.dependency};`;
            case "boolean":
                return `var ${dependency.name} = ${dependency.name}_1 = !!${dependency.dependency ? 1 : 0};`;
            case "function":
                return `var ${dependency.name} = ${dependency.name}_1 = ${exports.functionToString(dependency.dependency)};`;
            case "object":
                return `var ${dependency.name} = ${dependency.name}_1 = ${exports.objectToString(dependency.dependency)};`;
            default:
                return "";
        }
    };
    exports.functionToString = (fn) => {
        const fnString = fn.toString();
        if (typeof fn !== "function" || !fnString || fnString.length === 0) {
            return "function(){}";
        }
        return fnString.startsWith("(") || fnString.startsWith("function")
            ? fnString
            : `function ${fnString}`;
    };
    exports.objectToString = (obj) => {
        if (typeof obj === "function") {
            return exports.functionToString(obj);
        }
        if (typeof obj !== "object") {
            return JSON.stringify(obj);
        }
        const mapResult = objectFunctionMapper(obj);
        let result = JSON.stringify(mapResult);
        for (const entry of functionMap) {
            result = result.replace(new RegExp(`"${entry[0].replace(/\$/g, "\\$")}"`, "g"), entry[1]);
        }
        return result;
    };
    const objectFunctionMapper = (obj) => {
        const working = {};
        for (const prop in obj) {
            switch (typeof obj[prop]) {
                case "function":
                    const key = `$$Function${counter++}$$`;
                    functionMap.set(key, obj[prop].toString());
                    working[prop] = key;
                    break;
                case "object":
                    const childObject = objectFunctionMapper(obj[prop]);
                    working[prop] = childObject;
                    break;
                default:
                    working[prop] = obj[prop];
            }
        }
        return working;
    };
});
//# sourceMappingURL=utils.js.map