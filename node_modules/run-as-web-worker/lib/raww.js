(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./utils", "tslib"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const utils_1 = require("./utils");
    const tslib_1 = require("tslib");
    const tslibDependencies = {
        __extends: tslib_1.__extends,
        __assign: tslib_1.__assign,
        __rest: tslib_1.__rest,
        __decorate: tslib_1.__decorate,
        __param: tslib_1.__param,
        __metadata: tslib_1.__metadata,
        __awaiter: tslib_1.__awaiter,
        __generator: tslib_1.__generator,
        __exportStar: tslib_1.__exportStar,
        __values: tslib_1.__values,
        __read: tslib_1.__read,
        __spread: tslib_1.__spread,
        __spreadArrays: tslib_1.__spreadArrays,
        __await: tslib_1.__await,
        __asyncGenerator: tslib_1.__asyncGenerator,
        __asyncDelegator: tslib_1.__asyncDelegator,
        __asyncValues: tslib_1.__asyncValues,
        __makeTemplateObject: tslib_1.__makeTemplateObject,
        __importStar: tslib_1.__importStar,
        __importDefault: tslib_1.__importDefault
    };
    function RunAsWebWorker(...dependencies) {
        return function (target, propertyKey, descriptor) {
            target[propertyKey] = raww(target[propertyKey], ...dependencies);
            return target;
        };
    }
    exports.RunAsWebWorker = RunAsWebWorker;
    function raww(fn, ...dependencies) {
        if (fn == null || typeof fn !== "function") {
            return fn;
        }
        const dependencyBlobs = [
            tslibDependencies,
            { tslib: tslibDependencies }
        ]
            .concat(...dependencies)
            .reduce((arr, map) => {
            for (const entry in map) {
                arr.push({ name: entry, dependency: map[entry] });
            }
            return arr;
        }, [])
            .map(utils_1.getDependencyConstructor)
            .filter(v => v !== null)
            .map(str => str + "\r\n");
        const workerCode = () => {
            self.addEventListener("message", function (e) {
                $$$$(...e.data).then(result => {
                    self.postMessage({ result });
                }, err => {
                    self.postMessage({ error: err });
                });
            }, false);
        };
        function $$$$(...data) {
            return (fn).call({}, ...data);
        }
        const renderArray = dependencyBlobs.concat([
            `${$$$$.toString().replace("fn", utils_1.functionToString(fn))};`,
            "(",
            workerCode.toString(),
            ")();"
        ]);
        const workerBlob = new Blob(renderArray, { type: "text/javascript" });
        let worker = new Worker(window.URL.createObjectURL(workerBlob), {
            name: fn.name
        });
        let replaceFunction = (...args) => {
            return new Promise((resolve, reject) => {
                const act = (e) => {
                    worker.removeEventListener("message", act);
                    worker.removeEventListener("messageerror", err);
                    const result = e.data;
                    result.result ? resolve(result.result) : reject(result.error);
                };
                const err = (e) => {
                    worker.removeEventListener("message", act);
                    worker.removeEventListener("messageerror", err);
                    reject("an unserialisable response has been received");
                };
                worker.addEventListener("message", act, false);
                worker.addEventListener("messageerror", err, false);
                worker.postMessage(args);
            });
        };
        return replaceFunction;
    }
    exports.raww = raww;
});
//# sourceMappingURL=raww.js.map